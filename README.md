# 0630_aiffel
***
# pwd

pwd : Present Working Directory의 약자로 내가 현재 위치한 디렉토리 위치를 출력합니다.
***
인공지능에서 리눅스를 사용하는 이유?

- 대부분의 인공지능 라이브러리는 리눅스 기반에서 개발되었음.
- 리눅스의 안정성이 좋아 전반의 회사들은 리눅스 기반으로 서버를 운영함. 

***

shell관련 기본 지식

ex) root@wtetysocxvx7e6avqwhctccah-776475db6-h2swf:~#

@ 앞의 root은 현재 로그인한 사용자명입니다.
@ 뒤의 wtetysocxvx7e6avqwhctccah-776475db6-h2swf는 컴퓨터의 이름, 호스트명입니다.
: 뒤의 ~는 현재 위치입니다.
마지막 #는 현재 로그인한 사용자가 최고 관리자 계정(root)임을 나타내고 일반 사용자임의 경우에는 $로 표시됩니다.

우리가 지금 사용하고 있는 것과 같은 프로그램의 종류를 셸(shell) 이라고 하며, 우리는 이 껍데기를 통해 운영체제의 알맹이인 커널(kernel) 과 소통합니다. 

***

유닉스의 개발철학 = 모든 것은 파일이다.

***
# ls

ls: 현재 디렉토리 내의 파일 및 폴더들을 출력합니다.

ls --all, ls -a : 현재 디렉토리 내의 파일 및 폴더, 숨김파일 등을 전부 출력합니다.

-l: 각 파일 및 폴더의 권한, 소유자, 크기, 수정일시 등 자세한 정보를 출력합니다.
-h: 파일 크기를 바이트 수 대신 사람이 알아볼 수 있는 단위(1K, 234M, 2G 등)로 표시합니다.
-t: 파일 수정시간 순으로 정렬해서 출력합니다. 최신 파일이 위쪽으로 표시됩니다.
-r: 정렬 순서를 뒤집어 출력합니다. -rt의 형태로 쓰면 최신 파일이 아래쪽으로 표시되어 유용할 때가 있습니다.

한 글자 인자를 여럿 쓸 때에는 서로 붙여 쓸 수 있습니다. 즉, ls -l -a -h는 ls -lah로 쓸 수 있습니다. 
ls -lah (프로그램과 디렉토리를 포함한 모든 "파일"에는 소유 사용자와 소유 그룹이 있습니다. 소유 사용자가 할 수 있는 일, 소유 그룹에 소속된 사용자들이 할 수 있는 일, 그리고 그 밖의 사용자들이 할 수 있는 일을 파일마다 설정할 수 있습니다. )

깨알 tip : ls -alrt 가 유용할 때가 많습니다.

.은 현재폴더를 ..은 상위폴더를 가리킵니다.

리눅스에서 .으로 시작하는 파일들은 숨김파일을 의미합니다.

예를 들어 .bashrc와 .profile은 셸에 로그인 시 자동으로 불러오는 설정 파일들입니다.

ls 뒤에 폴더명을 넣어서 해당 폴더 안을 볼 수도 있습니다. ls --all folder를 입력해 folder 폴더 안에 어떤 파일들이 있는지 살펴봅니다.

***

# cd

cd: Change Directory의 약자로, 뒤에 따라오는 폴더로 내가 있는 셸의 현재 위치를 이동시킵니다.

cd root 입력 시 최고 관리자 계정

- 상대경로 : cd .. 을 이용하거나 어떠한 특정 위치에서 명령을 입력하는 시점에 내가 현재 있는 디렉토리에 영향을 받는 위치 표시방식을 상대경로라고 한다.

- 절대경로 : 예를 들어 home을 기준으로 모든 위치를 표현 하는 것이 절대경로라고 볼 수 있다.

/home: 사용자별 홈 디렉토리들이 있는 곳
/root: 최고 관리자 계정의 홈 디렉토리
/mnt: 저장장치(HDD, SSD)가 붙는 위치
/media: 이동식 미디어(USB 드라이브)가 붙는 위치
/tmp: 재부팅 시 삭제될 임시 파일들을 저장하는 폴더
/dev: 컴퓨터에 연결된 하드웨어 및 가상 기기(device)들을 가리키는 파일들
/proc: 현재 실행 중인 프로세스들을 가리키는 파일들
/etc: 각종 설정 파일들
/bin: 실행 가능한 프로그램(binary)들
/sbin: 시스템 관리용 프로그램들
/usr: 다중 사용자 모드에서 사용 가능한 파일 및 프로그램들 (root 계정만 있는 단일 사용자 모드에서는 사용 불가)
/var: 캐시, 로그 등 시스템 구동 간 계속 내용이 바뀌는 파일들

ps -e를 입력하여 현재 실행 중인 프로세스들을 확인합니다
ps: 현재 터미널과 관련된 프로세스 목록을 출력합니다.
ps -ef: 모든 터미널에서 현재 실행중인 프로세스 목록 및 부가정보를 출력합니다.
grep: 입력으로 전달된 내용에서 특정 문자열을 포함한 라인만 선택해서 출력합니다. 파이프(|)를 통해 다른 명령문 실행결과와 결합해서 사용할 때 특히 유용합니다.
sudo: 이어지는 명령을 최고 관리자 권한으로 실행합니다.
kill: PID에 해당하는 프로세스에 시그널을 보냅니다.
which: 명령어의 전체 경로를 출력합니다.
echo: 뒤에 입력된 내용을 출력하라는 명령어
shell 에서 단어 앞에 $가 붙으면 환경 변수(environment variable) 를 의미합니다. 파이썬의 변수처럼, 환경 변수는 운영체제가 프로세스 단위로 사용하는 변수입니다. 즉, 우리가 echo $PATH는 PATH라는 이름의 환경 변수($)의 값을 출력(echo)하라는 뜻입니다.

$ echo $PATH
PATH 환경 변수는 셸이 프로그램을 실행할 때 참조할 경로들을 나타냅니다. 값을 보면 디렉토리 여러 개가 :로 구분되어 있는 것을 알 수 있는데, 만약 동일한 이름의 프로그램이 여러 디렉토리에 설치되어 있다면, PATH 내 순서 상 앞에 있는 디렉토리의 프로그램을 실행합니다. 아나콘다(Anaconda)를 설치했다면, 우분투에 기본으로 설치된 파이썬 대신 아나콘다가 설치한 파이썬을 사용하도록 PATH의 값이 변경되어 있을 겁니다. 마찬가지로 which python을 통해 확인해볼 수 있습니다.

참고로 PATH 환경 변수의 기본값은 사용자가 로그인할 때 운영체제가 자동으로 정의하지만, export를 이용해 사용자가 직접 수정할 수도 있습니다.

export: 셸 변수나 함수를 현재 환경으로 내보냅니다.

env: 명령어가 제공된다면 해당 명령어를 새로운 환경에서 실행합니다. 명령어가 제공되지 않은 경우 현재 환경의 정보를 출력합니다.


***

# 운영체제

운영체제 : 컴퓨터의 다양한 하드웨어 장치들과 더불어 소프트웨어를 관리하는 시스템을 일컫습니다.

***

GUI 셸의 경우, 윈도우에는 우리에게 친숙한 시작 버튼을 포함하는 셸을 Windows shell이 라 부르고, 맥 OS의 경우는 Aqua라는 이름을 갖고 있습니다. 리눅스 계열 운영체제는 GNOME, Unity(동명의 게임 엔진과는 별도의 프로그램) 등이 있지만, 단독으로 동작하기보다 보통 Xorg 등 다른 종류의 프로그램들과 함께 사용됩니다.

CLI 셸로는 윈도우 운영체제의 cmd.exe와 PowerShell이 있고, 우분투 및 맥 OS에서는 CLI 셸로서 기본으로 sh와 여기에 몇 가지 편의기능을 덧붙인 bash가 설치되어 있습니다. 이 외에도 csh, fish, zsh 등 다양한 CLI 셸을 직접 설치하여 사용할 수 있습니다. 또한 zsh처럼 테마 및 플러그인을 지원하는 셸의 경우 모양과 편의기능을 입맛에 따라 꾸밀 수 있습니다.

***

# 프로세스와 스레드

프로그램 은 컴퓨터가 수행할 작업을 기록해놓은 것을 뜻합니다. 프로그램이 실제로 작업으로서 수행될 때 운영체제는 이를 프로세스(process) 라는 단위로 관리합니다. 즉, 운영체제는 프로세스 단위로 메모리와 CPU 연산 등 컴퓨팅 자원을 분배합니다.

메모리 관리 : 운영체제는 프로세스가 컴퓨터의 전체 메모리 어디든지 쓸 수 있도록 하는 것이 아니라 가상 메모리(virtual memory)로서 일부만 떼어서 제공해줌으로써, 다른 프로세스의 메모리 또는 운영체제 자체가 사용하고 있는 커널 메모리를 훔쳐볼 수 없도록 합니다. 이것을 운영체제의 중요한 보안 기제 중 하나인 프로세스 격리(process isolation)라고 부르며, 때문에 프로세스들이 서로 소통하기 위해서는 별도로 허용된 프로세스 간 통신 (Inter-Process Communication, IPC) 기법들을 사용해야 합니다.

CPU 자원 관리 : 메모리는 주소로서 프로세스에게 제공되지만, CPU 연산의 경우 코어 단위로 프로세스에 제공됩니다. 프로세스는 스레드(thread) 라는 단위로 코어를 하나씩 사용할 수가 있는데, 프로세스가 하나 시작되면 기본적으로 하나의 스레드를 가지고 시작하지만, 개발자는 프로그램이 더 많은 스레드를 사용하도록 설계하여 다중 CPU 코어의 이점을 극대화할 수 있습니다.

프로세스는 운영체제가 메모리를 할당하는 작업단위라면, 스레드는 프로세스가 할당받은 메모리를 활용하는 실행단위입니다.
하나의 프로그램 안에서 여러개의 프로세스를 활용하는 것을 멀티프로세싱(Multiprocessing) , 하나의 프로세스 안에서 여러개의 스레드를 활용하는 것을 멀티스레딩(Multithreading) 이라고 합니다.

참고로 kill은 그 자체로 프로세스를 죽이는 명령이 아니라, 프로세스에 신호를 보내는 명령어입니다. 강제종료하는 KILL 외에도, 프로그램 실행 중에 Ctrl+C를 누르면 전달되는 INT (interrupt) 신호나, 프로세스를 종료하기 전에 해당 프로세스에게 해명할 기회를 주는 TERM (terminate) 신호도 있습니다.

결국, 프로세스 끼리는 서로 간섭할 수 없으며 커널에 직접 간섭을 요청하는 신호를 보낼 수는 있다. 

현재 우리가 사용하는 터미널 창은 엄밀히 말하면 그래픽으로 터미널을 묘사하는  터미널 에뮬레이터라고 볼 수 있다.
***
# 패키지 관리자

우분투 운영체제는 공식적으로 APT(Advanced Packaging Tool)라는 패키지 관리자(package manager) 를 제공합니다.

패키지 관리자 : 공인 저장소에서 프로그램과 라이브러리(다른 프로그램들이 참조하여 사용할 수 있는 코드)를 패키지 단위로 설치하고 관리할 수 있도록 하는 프로그램입니다.

apt-get: APT 패키지 관리자를 통해 공인 저장소에서 패키지를 가져다 설치하거나 제거합니다.

purge : 파일 삭제 시 해당 프로그램의 설정 파일까지 모두 삭제시킬 수 있습니다

ps -ef : 프로세스마다 누구의 권한으로 실행되는지(UID, User ID) 확인할 수 있습니다.
***
# 그룹

컴퓨터에 어떤 그룹들이 있고, 해당 그룹마다 어떤 사용자들이 들어있는지 한번 확인해 봅시다. 유닉스 계열 운영체제에서는 설정 파일이나 장치 모두 파일로 접근 가능해야 한다는 철학이 있기 때문에, 그룹 설정도 텍스트 파일로 저장되어 있습니다.

cat: 하나 이상의 텍스트 파일을 순서대로 출력합니다.(`cat` 명령어는 고양이가 아니라 concatenate(이어붙이다)의 약자)

참고: 사용자들의 목록은 /etc/passwd에 기록되어 있는데, 원래 예전에는 해당 파일에서 사용자의 비밀번호까지 기록했기 때문입니다. 이제 대부분의 리눅스 기반 운영체제에서 비밀번호는 최고 관리자만 접근 가능한 /etc/shadow 파일에 암호화되어 저장됩니다.
***

# 접근권한

$ ls -lah
total 48K
drwxr-xr-x 1 root root 4.0K Jun  7 08:34 .
drwxr-xr-x 1 root root 4.0K Jun  7 05:10 ..
drwxrwxrwx 2 root root    0 Jun  2 02:45 aiffel
-rw------- 1 root root  12K Jun  7 08:24 .bashrc.swp
drwxr-xr-x 1 root root 4.0K Apr 19 09:30 .cache
drwxrwsr-x 2 root root 4.0K Apr 19 09:30 .conda
drwx------ 3 root root 4.0K Jun  7 08:34 .config
drwxr-xr-x 2 root root 4.0K Jun  4 03:42 data
drwx------ 1 root root 4.0K Apr 19 09:23 .jupyter
drwxr-xr-x 3 root root 4.0K Jun  7 05:10 .local
-rw-r--r-- 1 root root  170 Apr 19 09:28 .wget-hsts

* 3번 열은 소유 사용자이고, 4번째 열은 소유 그룹입니다. 

chown: 대상 파일의 소유 사용자와 그룹을 변경합니다.
참고로 위 명령어만으로는 디렉토리 내용물까지 소유자가 변경되지는 않습니다. 디렉토리 내의 모든 파일들에 대해 적용하려면 -R 옵션을 사용해야 합니다.

drwxr-xr-x라고 무언가 적혀있는데, 이 부분이 바로 권한을 표기하는 부분입니다. 첫 글자인 d는 해당 파일이 디렉토리인지 또는 일반 파일인지 여부를 나타냅니다. 그 뒤를 잇는 글자들은 각각 3 글자씩 소유 사용자 , 소유 그룹 , 기타 사용자 에게 허용된 읽기(read, r) , 쓰기(write, w) , 실행하기(execute, x)

예를 들어 drwxr-xr-x는 해당 파일이 디렉토리이고(d), 소유자는 읽고(r) 쓰고(w) 실행(x)하는 모든 동작이 가능하지만, 소유 그룹 소속 사용자와 기타 사용자들은 읽고 실행하기만 가능하다는 것을 표시합니다.

권한은 숫자로도 표시할 수 있습니다. 기본적으로 세 가지 권한 rwx를 각각의 이진수 자리로 봅니다. 세 자리 이진수 숫자를 해석하면 사용자, 그룹, 기타 사용자에게 부여된 권한을 1자리 십진수 숫자로 나타낼 수 있습니다. 예를 들어 rwxr-xr-x를 이진수로 나타내면 111101101이고, 이는 구분 별로 다음과 같습니다.

사용자: 이진수 111 = 십진수 7
그룹: 이진수 101 = 십진수 5
기타 사용자: 이진수 101 = 십진수 5
종합: 755

* 참고로 실행하기(x)의 경우 프로그램이라면 실제 실행할 수 있다는 것을 나타내지만, 디렉토리의 경우 해당 폴더 안으로 cd로 이동할 수 있는지 여부를 나타냅니다.

 - chmod 명령어 : 대상 파일의 권한을 변경합니다.

chmod 명령어를 사용하면 권한을 변경할 수 있습니다. aiffel 폴더의 권한을 한번 변경해 봅시다. 모두에게 모든 권한을 끄기 위해서 숫자 표기로 000을 입력합니다. (000 = 000000000 = ---------) 아래와 같이 test 디렉토리를 만들고 chmod 명령어를 활용하여 권한을 변경하여 보겠습니다.

 mkdir test
$ ls -lah
total 56K
drwxr-xr-x 1 root root 4.0K Jun  7 09:27 .
drwxr-xr-x 1 root root 4.0K Jun  7 05:10 ..
drwxrwxrwx 2 root root    0 Jun  2 02:45 aiffel
drwxr-xr-x 2 root root 4.0K Jun  7 09:27 test
root@wtetysocxvx7e6avqwhctccah-776475db6-h2swf:~# chmod 000 aiffel_test/
root@wtetysocxvx7e6avqwhctccah-776475db6-h2swf:~# ls -l
d--------- 2 root root 4096 Jun  7 09:27 test

***

# 딥러닝에 GPU를 사용하는 이유

CPU는 처리할 수 있는 명령어도 많고 복잡한 연산을 수행하지만 GPU는 코어 수를 엄청 늘리는 방법으로 다차원 행렬 연산에 특화되어 있습니다.
단순하고 양이 많은 데이터처리를 해야하는 입장에서, 복잡한 일을 처리할 수 있는 적은 양의 CPU를 이용하는 것 보다는 간단한 연산만 가능하지만 방대한 양의 데이터를 처리할 수 있는 GPU가 더 이점이 있는 것입니다.

***

# 딥러닝과 저장장치의 연관 관계

GPU를 쓰면 '연산'이 빨라져 딥러닝 모델이 무조건 빨라질 것 같지만, 사실 모델을 학습시키다 보면 속도에 병목 지점이 GPU/CPU 처리속도가 아닌 경우도 많습니다. (ex:고화질 이미지로 모델을 학습시키는데 속도가 너무 느린경우)

데이터를 읽어오는 데에 시간이 너무 많이 소요되고 있다면, 저장장치를 SSD로 변경하거나, 미리 여러 개의 스레드를 사용하여 RAM 메모리에 올려두는 방법으로 해결할 수 있습니다.

# 가상화

가상화(virtualization) 는 이처럼 하나의 컴퓨터를 쪼개어 여러 대의 컴퓨터가 있는 것처럼 사용하게 하는 기술입니다. 가상화에서 실제 물리적인 서버를 호스트(host), 그 안에서 돌아가는 가상 서버를 게스트(guest) 라고 합니다.

가상화에는 여러 가지 종류가 있습니다. 가상머신(Virtual Machine) 가상화의 경우 게스트 자체에 운영체제가 돌아가지만, 컨테이너(Container) 가상화 의 경우, 마치 화장실과 주방을 공유하는 것처럼, 게스트들이 호스트의 운영체제 커널을 공유합니다. 물론 커널의 기능만 공유할 뿐, 프로세스나 자원 등은 서로 철저히 격리하여 서로 간섭할 수 없도록 하는 것이 핵심기술입니다.

도커(Docker) 는 이런 컨테이너 가상화를 손쉽게 제공하는 프로그램입니다. 한 곳에서 실행 환경(우분투 버전, 라이브러리, 필요한 프로그램들)을 컨테이너로 구성해놓은 다음에 그걸 그대로 클라우드로 가져가서 실행하거나, 굳이 클라우드가 아니어도 내 컴퓨터에서 여러 개의 독립된 작업 환경을 구분하는 데에 사용할 수 있습니다.

그렇다고 가상화가 무조건 클라우드 컴퓨팅과 함께하는 개념은 아닙니다. 내 컴퓨터에서 파이썬 버전을 여러 가지 사용하고 각각 패키지를 구분하여 관리할 수 있게 해주는 아나콘다(Anaconda)나 VirtualEnv는 클라우드 컴퓨팅과 크게 관계가 없지만, 가상화의 한 종류로 볼 수 있습니다.

# 알아두면 좋을 셸 유용한 기능

터미널 에뮬레이터에서 무언가를 복사하거나 붙여넣을 때에는 Ctrl+Shift+C, Ctrl+Shift+V를 사용해야 합니다.
위아래 화살표를 통해 이전에 실행한 명령들을 다시 입력할 수 있습니다.
history 명령을 통해 기존에 실행한 명령들을 표시할 수 있습니다. 여기서 나오는 번호를 참고하여 !번호를 실행하면 해당 번호의 명령이 다시 실행됩니다.
Ctrl+A, Ctrl+E를 통해 명령어의 앞, 뒤로 커서를 이동할 수 있습니다.
clear 명령어 또는 Ctrl+L을 통해 기존에 터미널에 출력되었던 내용을 깨끗이 지울 수 있습니다.
실수로 Ctrl+z를 눌러 프로세스를 중지시켰다면, fg를 통해 다시 재개시킬 수 있습니다.
실수로 vi 편집기에 처음 들어갔다면, Ctrl+C 또는 Esc를 누른 뒤 :q!를 입력하고 엔터를 눌러 편집기를 종료할 수 있습니다.
sudo apt install curl 및 curl parrot.live를 통해 춤추는 앵무새를 볼 수 있습니다.( 클라우드에서는 작동이 안되니 로컬에서 테스트 해보세요 !)

***
#!/bin/bash는 이 스크립트 파일을 실행할 때 어떤 프로그램을 사용해야 할지 알려줍니다. 또한 실제로 이 파일을 실행하기 위해 해당 파일에 chmod로 실행 권한을 추가해야 합니다.

$ chmod +x test.sh
$ ./test.sh
Hello
Bye

- 파이썬도 가능!

#!/usr/bin/python
print("Hello")

셸에도 파이썬처럼 조건문과 연산자들이 있습니다. ||를 써서 이전 명령이 false를 반환한 경우에만 다음 명령을 실행하거나, &&로 이전 명령이 true를 반환한 경우에만 다음 명령을 실행할 수 있습니다.

$ false || echo "false"
false
$ false && echo "false"
$ true && echo "true"
true
$ true || echo "true"

>를 통해 명령어의 결과를 파일에 저장하는 것도 가능합니다. >>를 쓰면 명령어의 결과가 기존 파일 뒤에 추가됩니다.

$ echo hello > test.txt
$ cat test.txt
hello
$ echo hello again >> test.txt
$ cat test.txt
hello
hello again

또는 |를 통해 앞의 명령어의 결과를 입력으로 받아 이어서 처리할 수 있습니다. 예를 들어 아래와 같은 내용의 텍스트 파일(fruits.txt)이 있다면,

Orange
Apple
Grape

sort: 입력된 텍스트를 줄 단위로 정렬합니다.

$ cat fruits.txt
Orange
Apple
Grape
$ cat fruits.txt | sort
Apple
Grape
Orange

***

# 명령어 모음

셸 환경
history: 셸 명령어 이력을 출력합니다.
man: 프로그램의 매뉴얼 페이지를 출력합니다.
which: 명령어의 전체 경로를 출력합니다.
export: 셸 변수나 함수를 현재 환경으로 내보냅니다.
env: 명령어가 제공된다면 해당 명령어를 새로운 환경에서 실행합니다. 명령어가 제공되지 않은 경우 현재 환경의 정보를 출력합니다.
텍스트 처리
echo: 뒤이어 입력한 내용을 출력합니다.
cat: 하나 이상의 텍스트 파일을 순서대로 출력합니다.
sort: 입력된 텍스트를 줄 단위로 정렬합니다.
less: 텍스트 파일의 내용을 자유롭게 조회하고 검색합니다.
head: 텍스트 파일의 앞 몇 줄만 출력합니다.
tail: 텍스트 파일의 마지막 몇 줄만 출력합니다.
cut: 텍스트를 구분자(delimiter)에 따라 나눕니다.
uniq: 텍스트 중 중복 값들을 제거합니다.
grep: 정규식을 활용해 텍스트를 검색합니다.
wc: 텍스트를 단어, 줄, 문자 등 단위로 셉니다.
comm: 텍스트 파일을 비교합니다.
zcat: 압축된 텍스트 파일을 출력합니다.
sed: 정규식을 활용해 텍스트를 변형합니다.
awk: 텍스트를 스캔하고 변형합니다.
파일 제어 및 이동
ls: 현재 디렉토리 내의 파일 및 폴더들을 출력합니다.
cd: Change Directory의 약자로, 뒤에 따라오는 폴더로 내가 있는 셸의 현재 위치를 이동시킵니다.
cp: 파일을 복사합니다.
mv: 파일을 이동합니다.
rm: 파일을 삭제합니다. 폴더를 삭제하기 위해서는 -r (recursive) 옵션을, 빈 폴더가 아니더라도 내부까지 삭제하려면 -f (force) 옵션을 함께 사용해야 합니다.
chown: 대상 파일의 소유 사용자와 그룹을 변경합니다.
chmod: 대상 파일의 권한을 변경합니다.
find: 파일을 찾습니다.
pwd: Present Working Directory의 약자입니다. 현재 내가 >위치한 디렉토리 위치를 출력합니다.
ln: 파일에 대한 링크를 생성합니다.
touch: 파일 접근 및 수정 시간을 변경합니다. 빈 파일을 만드는데도 사용할 수 있습니다.
tar: 파일 및 폴더를 하나의 아카이브 파일로 통합하고 압축합니다.
mount: 새로운 저장장치를 파일시스템으로서 추가합니다.
rename: 여러 파일들의 이름을 규칙에 따라 한번에 변경합니다.
df: 파일시스템의 남은 용량을 표시합니다.
시스템 및 프로세스 제어
sudo: 이어지는 명령을 최고 관리자 권한으로 실행합니다.
apt-get: APT 패키지 관리자를 통해 공인 저장소에서 패 >키지를 가져다 설치하거나 제거합니다.
ps: 현재 프로세스 목록을 출력합니다.
kill: PID에 해당하는 프로세스에 시그널을 보냅니다.
fg: 배경에서 실행되는 작업을 전경(foreground)으로 가져옵니다.
bg: 작업을 배경(backgound)으로 보냅니다.
jobs: 전경 및 배경 작업의 목록을 표시합니다.
기타
ssh: 원격으로 셸에 접속합니다.
tmux: 여러 개의 셸 세션을 관리하고, 터미널 접속이 끊어지더라도 셸 세션을 유지합니다.
watch: 이어지는 명령을 주기적으로 실행하여 표시합니다.
curl: 주어진 URL과 통신합니다.
wget: 네트워크를 통해 파일을 다운로드합니다.
scp: SSH를 통해 원격으로 파일을 전송합니다.
ssh-keygen: SSH 공개키 비밀키 쌍을 생성합니다.
ssh-copy: SSH 공개키를 해당 서버에 등록합니다.
rsync: 원격으로 파일을 동기화합니다.
xarg: 명령어를 구성하여 실행합니다. 이전 명령에서 인자를 넘겨받아 실행하거나, 다중 프로세스를 사용하여 명령을 병렬로 실행하는 등의 작업이 가능합니다.
cron: 주기적으로 실행될 명령을 등록합니다.
htop: 프로세스 목록 및 자원 사용량을 시각적으로 표시합니다.

***

root@w4grid1hz8sjkn1n2c8srkwg4-f7b468bc8-mwmlb:~/data# tail -n 891 titanic.csv | cut -d ',' -f 6 | sort | uniq -c
    314 female
    577 male
